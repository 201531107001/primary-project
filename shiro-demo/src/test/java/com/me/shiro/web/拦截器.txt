                                        拦截器机制
Shiro 使用了与 Servlet 一样的 Filter 接口进行扩展
1 、NameableFilter
NameableFilter给 Filter 起个名字，如果没有设置默认就是 FilterName；还记得之前的如 authc
吗？当我们组装拦截器链时会根据这个名字找到相应的拦截器实例；
2 、OncePerRequestFilter
OncePerRequestFilter 用于防止多次执行 Filter 的；也就是说一次请求只会走一次拦截器链；
另外提供 enabled 属性，表示是否开启该拦截器实例，默认 enabled=true 表示开启，如果不
想让某个拦截器工作，可以设置为 false 即可。
3 、ShiroFilter
ShiroFilter 是整个 Shiro 的入口点，用于拦截需要安全控制的请求进行处理，这个之前已经用过了。
4 、AdviceFilter
AdviceFilter 提供了 AOP 风格的支持，类似于 SpringMVC 中的 Interceptor：
boolean preHandle(ServletRequest request, ServletResponse response) throws Exception
void postHandle(ServletRequest request, ServletResponse response) throws Exception
void afterCompletion(ServletRequest request,ServletResponse response,Exception exception)
throws Exception;
preHandler：类似于 AOP 中的前置增强；在拦截器链执行之前执行；如果返回 true 则继续
拦截器链；否则中断后续的拦截器链的执行直接返回；进行预处理（如基于表单的身份验证、授权）
postHandle：类似于 AOP 中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）；
afterCompletion：类似于 AOP 中的后置最终增强；即不管有没有异常都会执行；可以进行
清理资源（如接触 Subject 与线程的绑定之类的）；
5 、PathMatchingFilter
PathMatchingFilter 提供了基于 Ant 风格的请求路径匹配功能及拦截器参数解析的功能，如“roles[admin,user]”
自动根据“，”分割解析到一个路径参数配置并绑定到相应的路径
boolean pathsMatch(String path, ServletRequest request)
boolean onPreHandle(ServletRequest request, ServletResponse response,Object mappedValue)
throws Exception
pathsMatch：该方法用于 path 与请求路径进行匹配的方法；如果匹配返回 true；
onPreHandle：在 preHandle 中，当 pathsMatch 匹配一个路径后，会调用 opPreHandler 方法
并将路径绑定参数配置传给 mappedValue；然后可以在这个方法中进行一些验证（如角色
授权），如果验证失败可以返回 false 中断流程；默认返回 true；也就是说子类可以只实现
onPreHandle 即可，无须实现 preHandle。如果没有 path 与请求路径匹配，默认是通过的（即preHandle 返回 true）。
6 、AccessControlFilter
AccessControlFilter 提供了访问控制的基础功能；比如是否允许访问/当访问拒绝时如何处理等：
abstract boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception;
boolean  onAccessDenied(ServletRequest  request,  ServletResponse  response,  Object mappedValue) throws Exception;
abstract boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception;
isAccessAllowed：表示是否允许访问；mappedValue 就是[urls]配置中拦截器参数部分，如
果允许访问返回 true，否则 false；
onAccessDenied：表示当访问拒绝时是否已经处理了；如果返回 true 表示需要继续处理；
如果返回 false 表示该拦截器实例已经处理了，将直接返回即可。
onPreHandle 会自动调用这两个方法决定是否继续处理：
    boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue)
        throws Exception {
        return isAccessAllowed(request, response, mappedValue) || onAccessDenied(request,
            response, mappedValue);
    }
另外 AccessControlFilter 还提供了如下方法用于处理如登录成功后/重定向到上一个请求：
void setLoginUrl(String loginUrl) //身份验证时使用，默认/login.jsp
String getLoginUrl()
Subject getSubject(ServletRequest request, ServletResponse response) //获取 Subject 实例
boolean isLoginRequest(ServletRequest request, ServletResponse response)//当前请求是否是登录请求
//将当前请求保存起来并重定向到登录页面
void saveRequestAndRedirectToLogin(ServletRequest request, ServletResponse response)throws IOException 
void saveRequest(ServletRequest request) //将请求保存起来，如登录成功后再重定向回该请求
void redirectToLogin(ServletRequest request, ServletResponse response) //重定向到登录页面

到 此 基 本 的 拦 截 器 就 完 事 了 ， 如 果 我 们 想 进 行 访 问的 控 制 就 可 以 继 承
AccessControlFilter；如果我们要添加一些通用数据我们可以直接继承 PathMatchingFilter。


                                        拦截器链









